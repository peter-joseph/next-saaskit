import{r as f,R as G}from"./iframe-D6Fs4So_.js";import{d as te,b as Ee,f as ke,a as Ye,c as qe,g as Le}from"./index-BhyzFoYa.js";import{a as Xe}from"./RSPContexts-87WB4FFh.js";import{$ as _e,C as Fe}from"./ColorThumb-FVY-DL0P.js";import{$ as ne,a as z}from"./Color-un__ps5G.js";import{$ as Ke}from"./useControlledState-Dbnf3Bgn.js";import{$ as K,a as me}from"./NumberFormatter-ZLOyqEzC.js";import{$ as Oe}from"./intlStrings-B9RetRud.js";import{$ as He,a as Ue,b as We,c as ge,d as je,e as ze}from"./useFocusRing-D9TQlOey.js";import{$ as ae}from"./useLabels-DMXpQ1Zb.js";import{$ as Ge}from"./useFormReset-WNSJlShQ.js";import{$ as Be}from"./useKeyboard-Clt4deHt.js";import{$ as be}from"./useMove-lZYEc65B.js";import{$ as Je}from"./context-TYPMPinS.js";import{$ as Qe}from"./useLocalizedStringFormatter-D0E0W94r.js";import{$ as Ze}from"./VisuallyHidden-CYtzeH6S.js";import{c as en}from"./utils-40lp9oEd.js";const nn=z("#ffffff");function an(r){let{value:n,defaultValue:t,colorSpace:d,xChannel:y,yChannel:D,onChange:g,onChangeEnd:S}=r;!n&&!t&&(t=nn),n&&(n=ne(n)),t&&(t=ne(t));let[$,T]=Ke(n,t,g),[h]=f.useState($),o=f.useMemo(()=>d&&$?$.toFormat(d):$,[$,d]),c=f.useRef(o),s=a=>{c.current=a,T(a)},i=f.useMemo(()=>o.getColorSpaceAxes({xChannel:y,yChannel:D}),[o,y,D]),u=o.getChannelRange(i.xChannel),q=o.getChannelRange(i.yChannel),{minValue:C,maxValue:v,step:x,pageSize:j}=u,{minValue:R,maxValue:m,step:b,pageSize:L}=q,[B,J]=f.useState(!1),A=f.useRef(!1),M=o.getChannelValue(i.xChannel),V=o.getChannelValue(i.yChannel),O=a=>{if(a===M)return;let p=o.withChannelValue(i.xChannel,a);s(p)},H=a=>{if(a===V)return;let p=o.withChannelValue(i.yChannel,a);s(p)};return{channels:i,xChannelStep:x,yChannelStep:b,xChannelPageStep:j,yChannelPageStep:L,value:o,defaultValue:n!==void 0?h:t,setValue(a){s(ne(a))},xValue:M,setXValue:O,yValue:V,setYValue:H,setColorFromPoint(a,p){let X=C+me(a,0,1)*(v-C),N=R+(1-me(p,0,1))*(m-R),P;X!==M&&(X=K(X,C,v,x),P=o.withChannelValue(i.xChannel,X)),N!==V&&(N=K(N,R,m,b),P=(P||o).withChannelValue(i.yChannel,N)),P&&s(P)},getThumbPosition(){let a=(M-C)/(v-C),p=1-(V-R)/(m-R);return{x:a,y:p}},incrementX(a=1){O(M+a>v?v:K(M+a,C,v,x))},incrementY(a=1){H(V+a>m?m:K(V+a,R,m,b))},decrementX(a=1){O(K(M-a,C,v,x))},decrementY(a=1){H(K(V-a,R,m,b))},setDragging(a){let p=A.current;A.current=a,S&&!a&&p&&S(c.current),J(a)},isDragging:B,getDisplayColor(){return o.withChannelValue("alpha",1)}}}const ye=r=>[0,60,120,180,240,300,360].map(n=>r.withChannelValue("hue",n).toString("css")).join(", "),$e=r=>`${r.withChannelValue("saturation",0)}, transparent`,tn={hue:ye,saturation:$e,lightness:()=>"black, transparent, white"},ln={hue:ye,saturation:$e,brightness:()=>"black, transparent"};function rn({direction:r,state:n,zChannel:t,xChannel:d,yChannel:y}){return f.useMemo(()=>{let g=r==="rtl"?"left":"right",S={},$=n.value.getChannelValue(t);switch(n.value.getColorSpace()){case"rgb":{let c=z("rgb(0, 0, 0)");S={background:[`linear-gradient(to ${g}, ${c.withChannelValue(d,0)}, ${c.withChannelValue(d,255)})`,`linear-gradient(to top, ${c.withChannelValue(y,0)}, ${c.withChannelValue(y,255)})`,c.withChannelValue(t,$)].join(","),backgroundBlendMode:"screen"};break}case"hsl":{let c=n.value.getColorChannels(),s=z("hsl(0, 100%, 50%)").withChannelValue(t,$),i=c.filter(u=>u!==t).map(u=>`linear-gradient(to ${u===d?g:"top"}, ${tn[u](s)})`).reverse();t==="hue"&&i.push(s.toString("css")),S={background:i.join(", ")};break}case"hsb":{let c=n.value.getColorChannels(),s=z("hsb(0, 100%, 100%)").withChannelValue(t,$),i=c.filter(u=>u!==t).map(u=>`linear-gradient(to ${u===d?g:"top"}, ${ln[u](s)})`).reverse();t==="hue"&&i.push(s.toString("css")),S={background:i.join(", ")};break}}let{x:T,y:h}=n.getThumbPosition();r==="rtl"&&(T=1-T);let o={forcedColorAdjust:"none"};return{colorAreaStyleProps:{style:{position:"relative",touchAction:"none",...o,...S}},thumbStyleProps:{style:{position:"absolute",left:`${T*100}%`,top:`${h*100}%`,transform:"translate(-50%, -50%)",touchAction:"none",...o}}}},[r,n,t,d,y])}function on(r){return r&&r.__esModule?r.default:r}function un(r,n){let{isDisabled:t,inputXRef:d,inputYRef:y,containerRef:D,"aria-label":g,xName:S,yName:$,form:T}=r,h=Qe(on(Oe),"@react-aria/color"),{addGlobalListener:o,removeGlobalListener:c}=He(),{direction:s,locale:i}=Je(),[u,q]=f.useState(null),C=f.useCallback((e=d)=>{e.current&&Ue(e.current)},[d]);Ge(d,n.defaultValue,n.setValue);let[v,x]=f.useState(!1),[j,R]=f.useState(!1),{xChannel:m,yChannel:b,zChannel:L}=n.channels,B=n.xChannelStep,J=n.yChannelStep,A=f.useRef(null),{keyboardProps:M}=Be({onKeyDown(e){if(!/^(PageUp|PageDown|Home|End)$/.test(e.key)){e.continuePropagation();return}e.preventDefault(),n.setDragging(!0),x(!0);let l;switch(e.key){case"PageUp":n.incrementY(n.yChannelPageStep),l="y";break;case"PageDown":n.decrementY(n.yChannelPageStep),l="y";break;case"Home":s==="rtl"?n.incrementX(n.xChannelPageStep):n.decrementX(n.xChannelPageStep),l="x";break;case"End":s==="rtl"?n.decrementX(n.xChannelPageStep):n.incrementX(n.xChannelPageStep),l="x";break}n.setDragging(!1),l&&(C(l==="x"?d:y),q(l))}}),V={onMoveStart(){A.current=null,n.setDragging(!0)},onMove({deltaX:e,deltaY:l,pointerType:w,shiftKey:E}){var k;let{incrementX:Z,decrementX:ee,incrementY:Y,decrementY:W,xChannelPageStep:ue,xChannelStep:se,yChannelPageStep:de,yChannelStep:ce,getThumbPosition:Ae,setColorFromPoint:Ie}=n;A.current==null&&(A.current=Ae());let{width:Me,height:Ne}=((k=D.current)===null||k===void 0?void 0:k.getBoundingClientRect())||{width:0,height:0},fe=e!==0||l!==0;if(w==="keyboard"){let pe=E&&ue>se?ue:se,he=E&&de>ce?de:ce;e>0&&s==="ltr"||e<0&&s==="rtl"?Z(pe):e<0&&s==="ltr"||e>0&&s==="rtl"?ee(pe):l>0?W(he):l<0&&Y(he),x(fe),u=fe&&Math.abs(l)>Math.abs(e)?"y":"x",q(u)}else A.current.x+=(s==="rtl"?-1:1)*e/Me,A.current.y+=l/Ne,Ie(A.current.x,A.current.y)},onMoveEnd(){p.current=!1,n.setDragging(!1),C(u==="x"?d:y)}},{moveProps:O}=be(V),{focusWithinProps:H}=We({onFocusWithinChange:e=>{e||(x(!1),R(!1))}}),a=f.useRef(void 0),p=f.useRef(!1),{moveProps:X}=be({onMoveStart(){p.current&&V.onMoveStart()},onMove(e){p.current&&V.onMove(e)},onMoveEnd(){p.current&&V.onMoveEnd()}}),N=e=>{n.isDragging||(a.current=e,x(!1),C(),n.setDragging(!0),typeof PointerEvent<"u"?o(window,"pointerup",P,!1):(o(window,"mouseup",P,!1),o(window,"touchend",P,!1)))},P=e=>{var l,w;((w=e.pointerId)!==null&&w!==void 0?w:(l=e.changedTouches)===null||l===void 0?void 0:l[0].identifier)===a.current&&(x(!1),C(),n.setDragging(!1),a.current=void 0,p.current=!1,typeof PointerEvent<"u"?c(window,"pointerup",P,!1):(c(window,"mouseup",P,!1),c(window,"touchend",P,!1)))},Q=(e,l,w,E)=>{let k=e.getBoundingClientRect(),{width:Z,height:ee}=k,Y=(w-k.x)/Z,W=(E-k.y)/ee;s==="rtl"&&(Y=1-Y),Y>=0&&Y<=1&&W>=0&&W<=1&&!n.isDragging&&a.current===void 0&&(p.current=!0,x(!1),a.current=l,n.setColorFromPoint(Y,W),C(),n.setDragging(!0),typeof PointerEvent<"u"?o(window,"pointerup",_,!1):(o(window,"mouseup",_,!1),o(window,"touchend",_,!1)))},_=e=>{var l,w;let E=(w=e.pointerId)!==null&&w!==void 0?w:(l=e.changedTouches)===null||l===void 0?void 0:l[0].identifier;p.current&&E===a.current&&(p.current=!1,x(!1),a.current=void 0,n.setDragging(!1),C(),typeof PointerEvent<"u"?c(window,"pointerup",_,!1):(c(window,"mouseup",_,!1),c(window,"touchend",_,!1)))},ve=t?{}:te({...typeof PointerEvent<"u"?{onPointerDown:e=>{e.pointerType==="mouse"&&(e.button!==0||e.altKey||e.ctrlKey||e.metaKey)||Q(e.currentTarget,e.pointerId,e.clientX,e.clientY)}}:{onMouseDown:e=>{e.button!==0||e.altKey||e.ctrlKey||e.metaKey||Q(e.currentTarget,void 0,e.clientX,e.clientY)},onTouchStart:e=>{Q(e.currentTarget,e.changedTouches[0].identifier,e.changedTouches[0].clientX,e.changedTouches[0].clientY)}}},X),xe=t?{}:te({...typeof PointerEvent<"u"?{onPointerDown:e=>{e.pointerType==="mouse"&&(e.button!==0||e.altKey||e.ctrlKey||e.metaKey)||N(e.pointerId)}}:{onMouseDown:e=>{e.button!==0||e.altKey||e.ctrlKey||e.metaKey||N(void 0)},onTouchStart:e=>{N(e.changedTouches[0].identifier)}}},H,M,O),{focusProps:Ve}=ge({onFocus:()=>{q("x")}}),{focusProps:Pe}=ge({onFocus:()=>{q("y")}});const le=e=>{const{target:l}=e;R(!0),l===d.current?n.setXValue(parseFloat(l.value)):l===y.current&&n.setYValue(parseFloat(l.value))};let U=je()||ze(),I=n.getDisplayColor();const re=f.useCallback(e=>`${j||v?h.format("colorNameAndValue",{name:I.getChannelName(e,i),value:I.formatChannelValue(e,i)}):[h.format("colorNameAndValue",{name:I.getChannelName(e,i),value:I.formatChannelValue(e,i)}),h.format("colorNameAndValue",{name:I.getChannelName(e===b?m:b,i),value:I.formatChannelValue(e===b?m:b,i)}),h.format("colorNameAndValue",{name:I.getChannelName(L,i),value:I.formatChannelValue(L,i)})].join(", ")}, ${I.getColorName(i)}`,[i,I,h,j,v,m,b,L]);let F=h.format("colorPicker"),we=ae({...r,"aria-label":g?h.format("colorInputLabel",{label:g,channelLabel:F}):F}),Se=ae({...r,"aria-label":g?h.format("colorInputLabel",{label:g,channelLabel:F}):F}),De=ae({...r,"aria-label":g?`${g}, ${F}`:void 0},U?F:void 0),oe=h.format("twoDimensionalSlider"),{visuallyHiddenProps:ie}=Ze({style:{opacity:"0.0001",width:"100%",height:"100%",pointerEvents:"none"}}),{colorAreaStyleProps:Te,thumbStyleProps:Re}=rn({direction:s,state:n,xChannel:m,yChannel:b,zChannel:L});return{colorAreaProps:{...De,...ve,...Te,role:"group"},thumbProps:{...xe,...Re,role:"presentation"},xInputProps:{...we,...ie,...Ve,type:"range",min:n.value.getChannelRange(m).minValue,max:n.value.getChannelRange(m).maxValue,step:B,"aria-roledescription":oe,"aria-valuetext":re(m),"aria-orientation":"horizontal","aria-describedby":r["aria-describedby"],"aria-details":r["aria-details"],disabled:t,value:n.value.getChannelValue(m),name:S,form:T,tabIndex:U||!u||u==="x"?void 0:-1,"aria-hidden":U||!u||u==="x"||v?void 0:"true",onChange:le},yInputProps:{...Se,...ie,...Pe,type:"range",min:n.value.getChannelRange(b).minValue,max:n.value.getChannelRange(b).maxValue,step:J,"aria-roledescription":oe,"aria-valuetext":re(b),"aria-orientation":"vertical","aria-describedby":r["aria-describedby"],"aria-details":r["aria-details"],disabled:t,value:n.value.getChannelValue(b),name:$,form:T,tabIndex:U||u==="y"?void 0:-1,"aria-hidden":U||u==="y"||v?void 0:"true",onChange:le}}}const sn=f.createContext(null),dn=f.forwardRef(function(n,t){[n,t]=Ee(n,t,Xe);let d=f.useRef(null),y=f.useRef(null),D=an(n),{colorAreaProps:g,xInputProps:S,yInputProps:$,thumbProps:T}=un({...n,inputXRef:d,inputYRef:y,containerRef:t},D),h=ke({...n,defaultClassName:"react-aria-ColorArea",defaultStyle:g.style,values:{state:D,isDisabled:n.isDisabled||!1}}),o=Ye(n,{global:!0});return delete o.id,G.createElement(qe.div,{ref:t,...te(o,g,h),slot:n.slot||void 0,"data-disabled":n.isDisabled||void 0},G.createElement(Le,{values:[[sn,D],[_e,{state:D,thumbProps:T,inputXRef:d,xInputProps:S,inputYRef:y,yInputProps:$,isDisabled:n.isDisabled}]]},h.children))});function Ce(r){return G.createElement(dn,{...r,className:en(r.className,"w-full max-w-56 aspect-square rounded-lg bg-neutral-300 dark:bg-neutral-800 forced-colors:bg-[GrayText]"),style:({defaultStyle:n,isDisabled:t})=>({...n,background:t?void 0:n.background})},G.createElement(Fe,null))}try{Ce.displayName="ColorArea",Ce.__docgenInfo={description:"",displayName:"ColorArea",props:{className:{defaultValue:{value:"'react-aria-ColorArea'"},description:"The CSS [className](https://developer.mozilla.org/en-US/docs/Web/API/Element/className) for the element. A function may be provided to compute the class based on component state.",name:"className",required:!1,type:{name:"ClassNameOrFunction<ColorAreaRenderProps>"}},xName:{defaultValue:null,description:"The name of the x channel input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefname).",name:"xName",required:!1,type:{name:"string"}},yName:{defaultValue:null,description:"The name of the y channel input element, used when submitting an HTML form. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#htmlattrdefname).",name:"yName",required:!1,type:{name:"string"}},form:{defaultValue:null,description:"The `<form>` element to associate the ColorArea with.\nThe value of this attribute must be the id of a `<form>` in the same document.\nSee [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Reference/Elements/input#form).",name:"form",required:!1,type:{name:"string"}},colorSpace:{defaultValue:null,description:"The color space that the color area operates in. The `xChannel` and `yChannel` must be in this color space.\nIf not provided, this defaults to the color space of the `color` or `defaultColor` value.",name:"colorSpace",required:!1,type:{name:"enum",value:[{value:'"rgb"'},{value:'"hsl"'},{value:'"hsb"'}]}},xChannel:{defaultValue:null,description:"Color channel for the horizontal axis.",name:"xChannel",required:!1,type:{name:"enum",value:[{value:'"hue"'},{value:'"saturation"'},{value:'"brightness"'},{value:'"lightness"'},{value:'"red"'},{value:'"green"'},{value:'"blue"'},{value:'"alpha"'}]}},yChannel:{defaultValue:null,description:"Color channel for the vertical axis.",name:"yChannel",required:!1,type:{name:"enum",value:[{value:'"hue"'},{value:'"saturation"'},{value:'"brightness"'},{value:'"lightness"'},{value:'"red"'},{value:'"green"'},{value:'"blue"'},{value:'"alpha"'}]}},isDisabled:{defaultValue:null,description:"Whether the ColorArea is disabled.",name:"isDisabled",required:!1,type:{name:"boolean"}},value:{defaultValue:null,description:"The current value (controlled).",name:"value",required:!1,type:{name:"string | Color"}},defaultValue:{defaultValue:null,description:"The default value (uncontrolled).",name:"defaultValue",required:!1,type:{name:"string | Color"}},id:{defaultValue:null,description:"The element's unique identifier. See [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/id).",name:"id",required:!1,type:{name:"string"}},children:{defaultValue:null,description:"The children of the component. A function may be provided to alter the children based on component state.",name:"children",required:!1,type:{name:"ChildrenOrFunction<ColorAreaRenderProps>"}},style:{defaultValue:null,description:"The inline [style](https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style) for the element. A function may be provided to compute the style based on component state.",name:"style",required:!1,type:{name:"StyleOrFunction<ColorAreaRenderProps>"}},render:{defaultValue:null,description:`Overrides the default DOM element with a custom render function.
This allows rendering existing components with built-in styles and behaviors
such as router links, animation libraries, and pre-styled components.

Requirements:

* You must render the expected element type (e.g. if \`<button>\` is expected, you cannot render an \`<a>\`).
* Only a single root DOM element can be rendered (no fragments).
* You must pass through props and ref to the underlying DOM element, merging with your own prop as appropriate.`,name:"render",required:!1,type:{name:'DOMRenderFunction<"div", ColorAreaRenderProps>'}},slot:{defaultValue:null,description:"A slot name for the component. Slots allow the component to receive props from a parent component.\nAn explicit `null` value indicates that the local props completely override all props received from a parent.",name:"slot",required:!1,type:{name:"string"}},dir:{defaultValue:null,description:"",name:"dir",required:!1,type:{name:"string"}},lang:{defaultValue:null,description:"",name:"lang",required:!1,type:{name:"string"}},hidden:{defaultValue:null,description:"",name:"hidden",required:!1,type:{name:"boolean"}},inert:{defaultValue:null,description:"",name:"inert",required:!1,type:{name:"boolean"}},translate:{defaultValue:null,description:"",name:"translate",required:!1,type:{name:"enum",value:[{value:'"yes"'},{value:'"no"'}]}}}}}catch{}export{Ce as C};
